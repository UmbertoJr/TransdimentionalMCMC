{
    "collab_server" : "",
    "contents" : "\nrequire(HI, quietly = T)\n\n\n\n#################################################### ARMS\n### Univariate densities\n## Unif(-r,r)\ny <- arms(runif(1,-1,1), function(x,r) 1, function(x,r) (x>-r)*(x<r), 5000, r=2)\nsummary(y); hist(y, probability = T, main = \"Unif(-r,r); r=2\")\n\n## Normal(mean , 1)\nnorldens <- function(x , mean) -(x- mean)^2/2\ny <- arms(runif(1,3,17), norldens, function(x, mean) ((x-mean)> -7)*((x-mean)<7), 5000, mean=10)\nsummary(y); hist(y,prob=TRUE,main=\"Gaussian(m,1); m=10\")\ncurve(dnorm(x,mean=10),3,17,add=TRUE)\n\n## truncated Normal(mean , 1)\nnorldens <- function(x , mean) -(x- mean)^2/2\ny <- arms(runif(1,10,11), norldens, function(x, mean) (x > 9)*(x<11), 5000, mean=10)\nsummary(y); hist(y,prob=TRUE,main=\"truncated Gaussian(m,1); m=10\")\n\n\n## Exponential(1)\ny <- arms(5, function(x) -x, function(x) (x>0)*(x<70), 5000)\nsummary(y); hist(y,prob=TRUE,main=\"Exponential(1)\")\ncurve(exp(-x),0,8,add=TRUE)\n\n## Gamma(4.5,1)\ny <- arms(runif(1,1e-4,20), function(x) 3.5*log(x)-x,\n          function(x) (x>1e-4)*(x<20), 5000)\nsummary(y); hist(y,prob=TRUE,main=\"Gamma(4.5,1)\")\ncurve(dgamma(x,shape=4.5,scale=1),1e-4,20,add=TRUE)\n      \n\n## Gamma(0.5,1) (this one is not log-concave)\ny <- arms(runif(1,1e-8,10), function(x) -0.5*log(x)-x,\n          function(x) (x>1e-8)*(x<10), 5000)\nsummary(y); hist(y,prob=TRUE,main=\"Gamma(0.5,1)\")\ncurve(dgamma(x,shape=0.5,scale=1),1e-8,10,add=TRUE)\n\n\n## Beta(.2,.2) (this one neither)\ny <- arms(runif(1), function(x) (0.2-1)*log(x)+(0.2-1)*log(1-x),\n          function(x) (x>1e-5)*(x<1-1e-5), 5000)\nsummary(y); hist(y,prob=TRUE,main=\"Beta(0.2,0.2)\", breaks = 30)\ncurve(dbeta(x,0.2,0.2),1e-5,1-1e-5,add=TRUE)\n\n\n## Triangular\ny <- arms(runif(1,-1,1), function(x) log(1-abs(x)), function(x) abs(x)<1, 5000)\nsummary(y); hist(y,prob=TRUE,ylim=c(0,1),main=\"Triangular\")\ncurve(1-abs(x),-1,1,add=TRUE)\n\n\n## Multimodal examples (Mixture of normals)\nlmixnorm <- function(x,weights,means,sds) {\n  log(crossprod(weights, exp(-0.5*((x-means)/sds)^2 - log(sds))))\n}\ny <- arms(0, lmixnorm, function(x,...) (x>(-100))*(x<100), 5000, weights=c(1,3,2),\n          means=c(-10,0,10), sds=c(1.5,3,1.5))\nsummary(y); hist(y,prob=TRUE,main=\"Mixture of Normals\")\ncurve(colSums(c(1,3,2)/6*dnorm(matrix(x,3,length(x),byrow=TRUE),c(-10,0,10),c(1.5,3,1.5))),\n      par(\"usr\")[1], par(\"usr\")[2], add=TRUE)\n\n\n### Bivariate densities\n## Bivariate standard normal\ny <- arms(c(0,2), function(x) -crossprod(x)/2,\n          function(x) (min(x)>-5)*(max(x)<5), 500)\nplot(y, main=\"Bivariate standard normal\", asp=1)\n\n\n## Uniform in the unit square\ny <- arms(c(0.2,.6), function(x) 1,\n          function(x) (min(x)> 0)*(max(x)<1), 500)\nplot(y, main=\"Uniform in the unit square\", asp=1)\npolygon(c(0,1,1,0),c(0,0,1,1))\n\n\n## Uniform in the circle of radius r\ny <- arms(c(0.2,0), function(x,...) 1,\n          function(x,r2) sum(x^2)<r2, 500, r2=2^2)\nplot(y, main=\"Uniform in the circle of radius r; r=2\", asp=1)\ncurve(-sqrt(4-x^2), -2, 2, add=TRUE)\ncurve(sqrt(4-x^2), -2, 2, add=TRUE)\n\n\n## Uniform on the simplex\nsimp <- function(x) if ( any(x<0) || (sum(x)>1) ) 0 else 1\ny <- arms(c(0.2,0.2), function(x) 1, simp, 500)\nplot(y, xlim=c(0,1), ylim=c(0,1), main=\"Uniform in the simplex\", asp=1)\npolygon(c(0,1,0), c(0,0,1))\n\n\n## A bimodal distribution (mixture of normals)\nbimodal <- function(x) { log(prod(dnorm(x,mean=3))+prod(dnorm(x,mean=-3))) }\ny <- arms(c(-2,2), bimodal, function(x) all(x>(-10))*all(x<(10)), 500)\nplot(y, main=\"Mixture of bivariate Normals\", asp=1)\n\n\n\n## A bivariate distribution with non-convex support      [ FIGATA CAZZO!!!!]\nsupport <- function(x) {\n  return(as.numeric( -1 < x[2] && x[2] < 1 &&\n                       -2 < x[1] &&\n                       ( x[1] < 1 || crossprod(x-c(1,0)) < 1 ) ) )\n}\nMin.log <- log(.Machine$double.xmin) + 10\nlogf <- function(x) {\n  if ( x[1] < 0 ) return(log(1/4))\n  else\n    if (crossprod(x-c(1,0)) < 1 ) return(log(1/pi))\n  return(Min.log)\n}\nx <- as.matrix(expand.grid(seq(-2.2,2.2,length=40),seq(-1.1,1.1,length=40)))\ny <- sapply(1:nrow(x), function(i) support(x[i,]))\nplot(x,type='n', asp=1)\npoints(x[y==1,],pch=1,cex=1,col='green')\nz <- arms(c(0,0), logf, support, 1000)\npoints(z,pch=20,cex=0.5,col='blue')\npolygon(c(-2,0,0,-2),c(-1,-1,1,1))\ncurve(-sqrt(1-(x-1)^2),0,2,add=TRUE)\ncurve(sqrt(1-(x-1)^2),0,2,add=TRUE)\nsum( z[,1] < 0 ) # sampled points in the square\nsum( apply(t(z)-c(1,0),2,crossprod) < 1 ) # sampled points in the circle\n\nz <- arms(c(0,0), logf, support, 1000)\npoints(z,pch=20,cex=0.5,col='blue')\npolygon(c(-2,0,0,-2),c(-1,-1,1,1))\ncurve(-sqrt(1-(x-1)^2),0,2,add=TRUE)\ncurve(sqrt(1-(x-1)^2),0,2,add=TRUE)\nsum( z[,1] < 0 ) # sampled points in the square\nsum( apply(t(z)-c(1,0),2,crossprod) < 1 ) # sampled points in the circle\n\n\n#################################################### convex.bounds\n## boundaries of a unit circle\nconvex.bounds(c(0,0), c(1,1), indFunc=function(x) crossprod(x)<1)\nx <- matrix(runif(10000,-1,1), ncol = 2)\no <- function(x) crossprod(x)<1\ny <- sapply(1:nrow(x), function(i) o(x[i,]))\nplot(x[y==1,])\n\n\n###################################################  trans.dens\n\n### Generate a sample from a mixture of 0,1,2-dim standard normals\nldens.list <- list(f0 = function(x) sum(dnorm(x,log=TRUE)),\n                   f1 = function(x) dnorm(x,log=TRUE),\n                   f2 = function() 0)\ntrans.mix <- function(y) {\n  trans.dens(y, ldens.list=ldens.list, which.models=0:2)\n}\ntrans.rmix <- arms(c(0,0), trans.mix, function(x) crossprod(x)<1e4, 500)\nrmix <- trans.dens(y=trans.rmix, ldens.list=ldens.list,\n                   which.models=0:2, back.transform = TRUE)\ntable(rmix[,2])/nrow(rmix) # should be about equally distributed\nplot(trans.rmix,col=rmix[,2]+3,asp=1, xlab=\"y.1\", ylab=\"y.2\",\n     main=\"A sample from the auxiliary continuous distribution\")\nx <- rmix[,-(1:2)]\nplot(x, col=rmix[,2]+3, asp=1,\n     main=\"The sample transformed back to the original space\")\n### trans.up as a right inverse of trans.dens\nset.seed(6324)\ny <- trans.up(x, ldens.list, 0:2)\nstopifnot(all.equal(x, trans.dens(y, ldens.list, 0:2, back.transform=TRUE)[,-(1:2)]))\n\n\n### More trans.up\nz <- trans.up(matrix(0,1000,2), ldens.list, 0:2)\nplot(z,asp=1,col=5) # should look uniform in a circle corresponding to model 2\nz <- trans.up(cbind(runif(1000,-3,3),0), ldens.list, 0:2)\nplot(z,asp=1,col=4) # should look uniform in a region corresponding to model 1\n\n### trans2, transBack2\nldens.list <- list(f0 = function(x) sum(dnorm(x,log=TRUE)),\n                   f1 = function(x) dnorm(x,log=TRUE))\ntrans.mix <- function(y) {\n  trans2(y, ldens.list=ldens.list, k=1)[-2]\n}\ntrans.rmix <- arms(c(0,0), trans.mix, function(x) crossprod(x)<1e2, 1000)\nrmix <- transBack2(y=trans.rmix, ldens.list=ldens.list, k=1)\ntable(rmix[,2]==1)/nrow(rmix) # should be about equally distributed\nplot(trans.rmix,col=(rmix[,2]==0)+3,asp=1, xlab=\"y.1\", ylab=\"y.2\",\n     main=\"A sample from the auxiliary continuous distribution\")\nplot(rmix, col=(rmix[,2]==0)+3, asp=1,\n     main=\"The sample transformed back to the original space\")\n### trunsUp2  #cresce di dimensione\nz <- t(sapply(1:1000, function(i) transUp2(c(-2+0.004*i,0), ldens.list, 1)))\nplot(z,asp=1,col=2)\n",
    "created" : 1518555394400.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3765363635",
    "id" : "960D4A1C",
    "lastKnownWriteTime" : 1518566510,
    "last_content_update" : 1518566510080,
    "path" : "C:/Users/Umbertojunior/Desktop/data science/Second Semestr/SDS 2/project 2/transdimentional Ar(p)/explore_hi.R",
    "project_path" : "explore_hi.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}